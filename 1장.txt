1장은 간단한 “hello, world” 프로그램의 일생 주기를 추적해서 
컴퓨터 시스템에서의 주요 아이디어와 주제들을 소개

### 1.1 정보는 비트와 컨텍스트로 이뤄진다.

- hello 프로그램은 프로그래머가 작성한 소스 프로그램으로 생명을 시작 (hello.c 텍스트 파일로 저장)
- 소스 프로그램은 1 or 0 으로 표시되는 비트들의 연속 (바이트라는 8bit로 구성된다.)

텍스트 문자 → ASKII표준을  사용하여 표시 → 각 문자를 바이트 길이의 정수 값으로 변환 → 각 바이트는 특정 문자에 대응되는 정수 값을 갖는다.

- 아스키 문자들로만 이뤄진 파일들은 텍스트 파일 이라고 부른다
- 이 외의 파일은 바이너리 파일이라 부른다.

### 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.

1. hello 실행
2. hello를 시스템에서 실행시키려면 C문장들은 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 번역되야한다.
 → 위 형태가 실행가능 목적 프로그램 형태로 합쳐져 바이너리 디스크 파일로 저장한다. (사람이 볼 수 없는 이진수로 이뤄진 파일로 변한다는 뜻)
3. 컴파일러 드라이브는 유닉스 시스템에서 소스파일 → 오브젝트 파일로 변경
→ 전처리, 컴파일러, 어셈블리어, 링커 4단계를 거쳐 컴파일 시스템이라고 부른다.

```powershell
linux> gcc -o hello hello.c
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e20dd342-c0cd-4dad-8080-d7dda40f01d2/Untitled.png)

1. 전처리(cpp)를 거쳐서 매크로를 처리한다.
    - #include, #define 이 대표적인 매크로이다.
    - 매크로 처리 후 .c→.i로 끝나는 새로운 C프로그램 탄생
2. 컴파일러(cc1)를 통해서 어셈블리 언어로 변환한다.
    - 어셈블리어 변환후 .i→.s로 번역하여 어셈블리어 프로그램 저장
3. 어셈블러(as)를 통해서 목적파일로 변환한다.
    - 여기서 gcc 결과물로 나오는.o 파일이 여기서 얘기하는 목적파일이다
4. 링커를 통해서 여러개의 목적파일을 하나의 실행파일로 변환한다

### 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.

기계어 코드 번역에 대한 부분은 아래와 같은 성능적 부분에 영향이 있기 때문에 동작 이해하면 좋당

1. 프로그램 성능 최적화 하기 (6장)
    - Q1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?
    - Q2) while 루프는 for 루프보다 더 효율적일까?
    - Q3) 포인터 참조가 배열 인덱스보다 더 효율적인가?
2. 링크에러 이해하기 (7장)
    - Q1) 링커가 어떤 참조를 플어낼 수 없다고 할때는 무엇을 의미하는지?
    - Q2) 정적변수와 번역변수의 차이?
    - Q3) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?
    - Q4) 링커와 관련된 에러들은 실행전에 나타나지 않는 걸까?
3. 보안약점 (3장)
    - Q1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?

### 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

그간 열심히 만들었던 실행파일을 유닉스 시스템에서 실행하기 위해서 쉘이라는 응용프로그램에 그 이름을 입력한다.

```powershell
linux>./hello
hello, world!
linux>
```

쉘은 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력받아 그 명령어를 실행한다. 

### 1.4.1 시스템의 하드웨어 조직

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41a9adfc-0562-4b6e-b641-53b4bdf7504d/Untitled.png)

**버스(Bues)**

- 시스템 내를 관통하는 전기적 배선군
- 컴포넌트들 간에 바이트 정보들을 전송 (word)
- 대부분 컴퓨터들은 4바이트(32비트) or 8바이트 (64비트) 워드 크기를 갖는다.

**입출력 장치(I/O)**

- 키보드, 마우스, 모니터,디스크 드라이브 등등
- 처음 실행가능 파일인 hello프로그램은 디스크에 저장됨. 입출력 장치는 입출력 버스와 *컨트롤러*나 *어댑터를* 통해 연결됨.
- 이 두 장치의 차이는 패키징에 있다. 컨트롤러는 디바이스 자체가 칩셋이거나 시스템의 인쇄기판(마더보드)에 장착됨.

**메인 메모리**

메인 메모리는 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치다. 

- 물리적 메모리 DRAM
- 논리적 메모리는 연속적인 바이트들의 배열로 각각 0부터 시작해서 고유의 주소를 가지고 있다.

**프로세서**

주처리장치(CPU) 또는 간단히 프로세서는 메인 메모리에 저장된 인스트럭션들을(컴퓨터가 알아들을 수 있는 기계어로 이루어져 있는 명령) 해독하는 엔진이다.

- 프로세서 중심에는 워드 크기의 저장장치 또는 프로그램카운터가 있다.
- 시스템 전원이 공급되고 끊길 때 까지 프로세서는 프로그램 카운터가 가르키는 곳의 인스트럭션을 반복적으로 실행
- PC값이 다음 인스트럭션의 위치를 가르키도록 업데이트 한다.
- 프로세서는 자신의 인스트럭션 집합 구조로 정의되는 매우 단순한 인스트럭션 실행 모델을 따라 작동하는 것처럼 보임.
- 프로세서는 PC가 가리키는 메모리로 부터 인스트럭션을 읽어오고, 이 인스트럭션에서 비트들을 해석하여 인스트럭션이 지정하는 간단한 동작을 실행하고, PC를 다음 인스트럭션 위치로 업데이트함.  이 새로운 위치는 방금 수행한 명령어와 메모리 상에서 연속적일 수도 있고, 그렇지 않을 수도 있다.
- 이와 같은 몇개의 단순한 동작들이 있고, 메인 메모리, 레지스터 파일, ALU 주위를 순환한다.

<aside>
📢 CPU가 실행하는 단순한 작업의 예

- 적재(LOAD): 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 값에 덮어쓰는 방식으로 복사함.
- 저장(SAVE): 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값을 덮어쓰는 방식으로 복사함.
- 작업(Operate): 두 레지스터의 값을 ALU로 복사하고 두 개의 워드로 수식연산을 수행한 뒤, 결과를 덮어쓰기 방식으로 레지스터에 저장함.
- 점프(Jump): 인스트럭션 자신으로부터 한 개의 워드를 추출하고, 이것을 PC에 덮어쓰기 방식으로 복사함.
</aside>

### 1.4.2 hello 프로그램의 실행

![hello 명령을 키보드에서 읽어들이는 과정](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4f0ec773-1e37-41a8-ab66-0f478f862113/Untitled.png)

hello 명령을 키보드에서 읽어들이는 과정

처음 쉘 프로그램은 자신의 인스트럭션을 실행하면서 사용자가 명령을 입력하기를 기다린다.

키보드로 hello를 입력하면 쉘 프로그램은 각각의 문자를 레지스터에 읽어 들인 후, 메모리에 저장한다.

엔터를 눌러 쉘 명령어 입력을 끝내고 쉘은 파일 내의 코드와 데이터를 복사하는 일련의 인스트럭션을 실행하여 디스크 → 메인 메모리로 로딩한다.

![실행파일을 디스크에서 메인 메모리로 로딩하는 과정](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/787e90eb-20a8-4baa-8f4e-4ce769d7a0b3/Untitled.png)

실행파일을 디스크에서 메인 메모리로 로딩하는 과정

직접메모리 접근 이라고 알려진 기법을 이용해서 데이터는 프로세서를 거치지 않고 디스크에서 메인 메모리로 직접 이동한다.

![출력 스트링을 메모리에서 화면으로 기록하는 과정](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e41a4dca-682a-4cc7-b8b8-dba1a72b6699/Untitled.png)

출력 스트링을 메모리에서 화면으로 기록하는 과정

hello목적파일의 코드와 데이터가 메모리에 적재된 후, 프로세서는 hello 프로그램의 main루틴의 기계어 인스트렉션을 실행하기 시작한다.

이 인스트럭션들은 출력 스트링을 메모리로부터 레지스터 파일로 복사하고 거기로부터 디스플레이 장치로 전송하여 화면에 글자들이 출력된다.